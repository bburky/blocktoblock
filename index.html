<!doctype html>
<meta charset="utf-8" />
<title>Block to Block</title>
<style>
canvas {
    position: absolute;
    margin: auto;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
}
</style>
<script src="http://cdnjs.cloudflare.com/ajax/libs/phaser/1.1.5/phaser.min.js"></script>
<script>window.Phaser || document.write('<script src="js/phaser.min.js"><\/script>')</script>
<script src="js/levels.js"></script>
<script>
var BLOCK_SIZE = 45;
var PLAYER_SPEED = BLOCK_SIZE*5;
var DIRECTION = {none: 0, up: 1, right: 2, down: 3, left: 4};
var BLOCK_IMAGES = ['block-blue', 'block-red', 'block-green'];

var upKey, downKey, leftKey, rightKey, wKey, aKey, sKey, dKey;
var soundHitBlock, soundHitPlayer;
var backgroundSprite;
var players, blocks;
var player1, player2
var collidingPlayer;

var level;
var levelComplete;

function preload() {
    game.load.image('player-1', 'img/player-1.png');
    game.load.image('player-2', 'img/player-2.png');
    game.load.image('block-blue', 'img/block-blue.png');
    game.load.image('block-red', 'img/block-red.png');
    game.load.image('block-green', 'img/block-green.png');
    game.load.image('block-goal', 'img/block-goal.png');
    game.load.audio('hit-block', ['snd/ToneWobble.mp3', 'snd/ToneWobble.ogg']);
    game.load.audio('hit-player', ['snd/Game-Shot.mp3', 'snd/Game-Shot.ogg']);

    for (var i = 0; i < levels.length; i++) {
        game.load.image(levels[i].backgroundImgSrc, levels[i].backgroundImgSrc);
    }
}

function create() {
    upKey = game.input.keyboard.addKey(Phaser.Keyboard.UP);
    downKey = game.input.keyboard.addKey(Phaser.Keyboard.DOWN);
    leftKey = game.input.keyboard.addKey(Phaser.Keyboard.LEFT);
    rightKey = game.input.keyboard.addKey(Phaser.Keyboard.RIGHT);
    wKey = game.input.keyboard.addKey(Phaser.Keyboard.W);
    dKey = game.input.keyboard.addKey(Phaser.Keyboard.D);
    aKey = game.input.keyboard.addKey(Phaser.Keyboard.A);
    sKey = game.input.keyboard.addKey(Phaser.Keyboard.S);

    soundHitBlock = game.add.audio('hit-block');
    soundHitPlayer = game.add.audio('hit-player');

    level = 0;
    createLevel();
}

function update() {
    if (wKey.isDown && player1.direction === DIRECTION.none) {
        player1.direction = DIRECTION.up;
    } else if (sKey.isDown && player1.direction === DIRECTION.none) {
        player1.direction = DIRECTION.down;
    } else if (aKey.isDown && player1.direction === DIRECTION.none) {
        player1.direction = DIRECTION.left;
    } else if (dKey.isDown && player1.direction === DIRECTION.none) {
        player1.direction = DIRECTION.right;
    }

    if (upKey.isDown && player2.direction === DIRECTION.none) {
        player2.direction = DIRECTION.up;
    } else if (downKey.isDown && player2.direction === DIRECTION.none) {
        player2.direction = DIRECTION.down;
    } else if (leftKey.isDown && player2.direction === DIRECTION.none) {
        player2.direction = DIRECTION.left;
    } else if (rightKey.isDown && player2.direction === DIRECTION.none) {
        player2.direction = DIRECTION.right;
    }

    for (var i = 0; i < players.length; i++) {
        var player = players.getAt(i);
        if (!player.moving) {
            switch (player.direction) {
                case DIRECTION.up:
                    var newPosition = new Phaser.Point(player.x, player.y - BLOCK_SIZE);
                    goToPoint(player, newPosition);
                    break;

                case DIRECTION.down:
                    var newPosition = new Phaser.Point(player.x, player.y + BLOCK_SIZE);
                    goToPoint(player, newPosition);
                    break;

                case DIRECTION.left:
                    var newPosition = new Phaser.Point(player.x - BLOCK_SIZE, player.y);
                    goToPoint(player, newPosition);
                    break;

                case DIRECTION.right:
                    var newPosition = new Phaser.Point(player.x + BLOCK_SIZE, player.y);
                    goToPoint(player, newPosition);
                    break;
            }
        }
    }

    if (!levelComplete && blocks.countLiving() === 0) {
        levelComplete = true;

        var text = "Level Complete";
        var style = { font: "72px Arial", fill: "#ff0044", align: "center" };
        var t = game.add.text(game.world.centerX, game.world.centerY, text, style);
        t.anchor.setTo(0.5, 0.5);

        var text = "Press any key to continue";
        var style = { font: "32px Arial", fill: "#ff0044", align: "center" };
        var t = game.add.text(game.world.centerX, game.world.centerY + 72, text, style);
        t.anchor.setTo(0.5, 0.5);

        game.input.keyboard.onUpCallback = function() {
            level = (level + 1) % levels.length;
            createLevel();
        }
        game.input.onUp.addOnce(game.input.keyboard.onUpCallback);
    } 

    game.camera.focusOnXY((player1.x + player2.x) / 2, (player1.y + player2.y) / 2);
}

function createLevel() {
    // var cleanup = [backgroundSprite, players, blocks];
    // for (var i = 0; i < cleanup.length; i++) {
    //     if (cleanup[i] && cleanup[i].exists) {
    //         cleanup[i].destroy();
    //     }
    // }
    game.world.destroy()
    // game.input.onUp is cleaned up by destroying the world
    game.input.keyboard.onUpCallback = undefined;

    levelComplete = false;

    game.stage.backgroundColor = levels[level].backgroundStyle;
    backgroundSprite = game.add.sprite(0, 0, levels[level].backgroundImgSrc);
    backgroundSprite.centerOn(game.width/2, game.height/2);
    var offset = {x: backgroundSprite.x, y: backgroundSprite.y}
    game.world.setBounds(0, 0, backgroundSprite.width, backgroundSprite.height);

    blocks = game.add.group();
    players = game.add.group();

    player1 = players.create(offset.x + BLOCK_SIZE*levels[level].startingPositions[0][0], offset.y + BLOCK_SIZE*levels[level].startingPositions[0][1], 'player-1', players);
    player1.name = 'player left';
    player1.destination = new Phaser.Point(player1.x, player1.y);
    player1.direction = DIRECTION.none;
    player1.moving = false;

    player2 = players.create(offset.x + BLOCK_SIZE*levels[level].startingPositions[1][0], offset.y + BLOCK_SIZE*levels[level].startingPositions[1][1], 'player-2', players);
    player2.name = 'player right';
    player2.destination = new Phaser.Point(player2.x, player2.y);
    player2.direction = DIRECTION.none;
    player2.moving = false;

    for (var i = 0; i < levels[level].board.length; i++) {
        for (var j = 0; j < levels[level].board[i].length; j++) {
            if (levels[level].board[i][j] === LEVEL_NORMAL_BLOCK) {
                blocks.create(offset.x + BLOCK_SIZE*j, offset.y + BLOCK_SIZE*i, BLOCK_IMAGES[(i+j)%BLOCK_IMAGES.length]);
            }
        }
    }
}

function goToPoint(player, point) {
    // using global collidingPlayer
    var collidingBlock;

    for (var i = 0; i < blocks.length; i++) {
        var block = blocks.getAt(i)
        if (block.alive) {
            if (block.x == point.x && block.y == point.y) {
                collidingBlock = block;
                break;
            }
        }
    }

    for (var i = 0; i < players.length; i++) {
        var otherPlayer = players.getAt(i)
        if (otherPlayer !== player) {
            if (otherPlayer.destination.equals(point)) {
                collidingPlayer = otherPlayer;
                break;
            }
        }
    }

    player.moving = true;
    player.destination = point;
    var tween = game.add.tween(player);
    tween.to({x: point.x, y: point.y}, PLAYER_SPEED);
    tween.onComplete.add(function() {
        player.moving = false;

        if (collidingBlock) {
            collidingBlock.kill();
            player.direction = DIRECTION.none;
            soundHitBlock.play();
        }

        // This may have been set by the other player
        if (collidingPlayer) {
            player.direction = DIRECTION.none;
            if (collidingPlayer !== player) {
                collidingPlayer = undefined;
                soundHitPlayer.play();
            }
        }
    });
    tween.start();
}

var game = new Phaser.Game(1000, 1000, Phaser.AUTO, '', {preload: preload, create: create, update: update});
</script>
