<!doctype html>
<meta charset="utf-8" />
<title>Block to Block</title>
<style>
canvas {
    position: absolute;
    margin: auto;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
}
</style>
<script src="http://cdnjs.cloudflare.com/ajax/libs/phaser/1.1.5/phaser.min.js"></script>
<script>window.Phaser || document.write('<script src="js/phaser.min.js"><\/script>')</script>
<script src="js/levels.js"></script>
<script>
var BLOCK_SIZE = 45;
var BORDER_WIDTH = 10;
var PLAYER_SPEED = BLOCK_SIZE*3;
var DIRECTION = {none: 0, up: 1, right: 2, down: 3, left: 4};
var BLOCK_IMAGES = ['block-blue', 'block-red', 'block-green'];

var LEVEL_NORMAL_BLOCK = 2;
var LEVEL_GOAL_BLOCK = 1;

var blurX, blurY;
var upKey, downKey, leftKey, rightKey, wKey, aKey, sKey, dKey, rKey;
var soundHitBlock, soundHitPlayer;
var backgroundSprite;
var players, blocks;
var player1, player2
var collidingPlayer;

var level;
var levelComplete;

function preload() {
    game.load.script('filterX', 'js/BlurX.js');
    game.load.script('filterY', 'js/BlurY.js');

    game.load.image('player-1', 'img/player-1-border.png');
    game.load.image('player-2', 'img/player-2-border.png');
    game.load.image('block-blue', 'img/block-blue.png');
    game.load.image('block-red', 'img/block-red.png');
    game.load.image('block-green', 'img/block-green.png');
    game.load.image('block-goal', 'img/block-goal.png');
    game.load.audio('hit-block', ['snd/ToneWobble.mp3', 'snd/ToneWobble.ogg']);
    game.load.audio('hit-player', ['snd/Game-Shot.mp3', 'snd/Game-Shot.ogg']);

    for (var i = 0; i < levels.length; i++) {
        game.load.image(levels[i].backgroundImgSrc, levels[i].backgroundImgSrc);
    }
}

function create() {
    blurX = game.add.filter('BlurX');
    blurY = game.add.filter('BlurY');

    upKey = game.input.keyboard.addKey(Phaser.Keyboard.UP);
    downKey = game.input.keyboard.addKey(Phaser.Keyboard.DOWN);
    leftKey = game.input.keyboard.addKey(Phaser.Keyboard.LEFT);
    rightKey = game.input.keyboard.addKey(Phaser.Keyboard.RIGHT);
    wKey = game.input.keyboard.addKey(Phaser.Keyboard.W);
    dKey = game.input.keyboard.addKey(Phaser.Keyboard.D);
    aKey = game.input.keyboard.addKey(Phaser.Keyboard.A);
    sKey = game.input.keyboard.addKey(Phaser.Keyboard.S);
    rKey = game.input.keyboard.addKey(Phaser.Keyboard.R);

    soundHitBlock = game.add.audio('hit-block');
    soundHitPlayer = game.add.audio('hit-player');

    level = 0;
    createLevel();
}

function update() {
    if (!levelComplete) {

        if (rKey.isDown) {
            createLevel();
        }

        if (wKey.isDown && player1.direction === DIRECTION.none) {
            player1.direction = DIRECTION.up;
        } else if (sKey.isDown && player1.direction === DIRECTION.none) {
            player1.direction = DIRECTION.down;
        } else if (aKey.isDown && player1.direction === DIRECTION.none) {
            player1.direction = DIRECTION.left;
        } else if (dKey.isDown && player1.direction === DIRECTION.none) {
            player1.direction = DIRECTION.right;
        }

        if (upKey.isDown && player2.direction === DIRECTION.none) {
            player2.direction = DIRECTION.up;
        } else if (downKey.isDown && player2.direction === DIRECTION.none) {
            player2.direction = DIRECTION.down;
        } else if (leftKey.isDown && player2.direction === DIRECTION.none) {
            player2.direction = DIRECTION.left;
        } else if (rightKey.isDown && player2.direction === DIRECTION.none) {
            player2.direction = DIRECTION.right;
        }

        for (var i = 0; i < players.length; i++) {
            var player = players.getAt(i);
            if (!player.moving) {
                switch (player.direction) {
                    case DIRECTION.up:
                        var newPosition = new Phaser.Point(player.x, player.y - BLOCK_SIZE);
                        goToPoint(player, newPosition);
                        break;

                    case DIRECTION.down:
                        var newPosition = new Phaser.Point(player.x, player.y + BLOCK_SIZE);
                        goToPoint(player, newPosition);
                        break;

                    case DIRECTION.left:
                        var newPosition = new Phaser.Point(player.x - BLOCK_SIZE, player.y);
                        goToPoint(player, newPosition);
                        break;

                    case DIRECTION.right:
                        var newPosition = new Phaser.Point(player.x + BLOCK_SIZE, player.y);
                        goToPoint(player, newPosition);
                        break;
                }
            }
        }

        if (countLivingGoalBlocks() === 0) {
            levelComplete = true;

            var text = "Level Complete";
            if (level === levels.length - 1) {
                text = "You Win!"
            }
            var style = { font: "72px Arial", fill: "#ff0044", align: "center" };
            var t = game.add.text(game.camera.width/2, game.camera.height/2, text, style);
            t.anchor.setTo(0.5, 1);

            var remainingBlocks = blocks.countLiving();
            if (remainingBlocks !== 0) {
                var text = "You missed " + remainingBlocks + " blocks";
                var style = { font: "36px Arial", fill: "#ff0044", align: "center" };
                var t = game.add.text(game.camera.width/2, game.camera.height/2 + 54, text, style);
                t.anchor.setTo(0.5, 1);
            }

            var text = "Press any key to continue";
            if (level === levels.length - 1) {
                text = "Press any key to restart game"
            }
            var style = { font: "36px Arial", fill: "#ff0044", align: "center" };
            var t = game.add.text(game.camera.width/2, game.camera.height/2 + (remainingBlocks === 0 ? 0 : 54) + 54, text, style);
            t.anchor.setTo(0.5, 1);

            game.input.keyboard.onUpCallback = function() {
                level = (level + 1) % levels.length;
                createLevel();
            }
            game.input.onUp.addOnce(game.input.keyboard.onUpCallback);
        }

        game.camera.focusOnXY((player1.x + player2.x) / 2, (player1.y + player2.y) / 2);
    }
}

function createLevel() {
    game.world.destroy() // I suppose it's fine to destroy the world?
    // game.input.onUp is cleaned up by destroying the world
    game.input.keyboard.onUpCallback = undefined;
    game.tweens.removeAll();

    levelComplete = false;

    document.body.style.background = levels[level].backgroundStyle;
    game.stage.backgroundColor = levels[level].backgroundStyle;
    backgroundSprite = game.add.sprite(0, 0, levels[level].backgroundImgSrc);
    backgroundSprite.centerOn(game.width/2, game.height/2);
    var offset = {x: backgroundSprite.x, y: backgroundSprite.y};
    game.world.bounds.x = backgroundSprite.x;
    game.world.bounds.y = backgroundSprite.y;
    game.world.bounds.width = backgroundSprite.width;
    game.world.bounds.height = backgroundSprite.height;

    blocks = game.add.group();
    players = game.add.group();

    player1 = players.create(offset.x + BLOCK_SIZE*levels[level].startingPositions[0][0] - BORDER_WIDTH, offset.y + BLOCK_SIZE*levels[level].startingPositions[0][1] - BORDER_WIDTH, 'player-1', players);
    player1.crop = new Phaser.Rectangle(-5,-5, player1.width+5, player1.height+5);
    player1.events.onOutOfBounds.add(outOfBounds);
    player1.name = 'player left';
    player1.destination = new Phaser.Point(player1.x, player1.y);
    player1.direction = DIRECTION.none;
    player1.moving = false;

    player2 = players.create(offset.x + BLOCK_SIZE*levels[level].startingPositions[1][0] - BORDER_WIDTH, offset.y + BLOCK_SIZE*levels[level].startingPositions[1][1] - BORDER_WIDTH, 'player-2', players);
    player2.events.onOutOfBounds.add(outOfBounds);
    player2.name = 'player right';
    player2.destination = new Phaser.Point(player2.x, player2.y);
    player2.direction = DIRECTION.none;
    player2.moving = false;

    for (var i = 0; i < levels[level].board.length; i++) {
        for (var j = 0; j < levels[level].board[i].length; j++) {
            if (levels[level].board[i][j] === LEVEL_NORMAL_BLOCK) {
                var block = blocks.create(offset.x + BLOCK_SIZE*j, offset.y + BLOCK_SIZE*i, BLOCK_IMAGES[(i+j)%BLOCK_IMAGES.length]);
                block.goal = false;
            } else if (levels[level].board[i][j] === LEVEL_GOAL_BLOCK) {
                var block = blocks.create(offset.x + BLOCK_SIZE*j, offset.y + BLOCK_SIZE*i, 'block-goal');
                block.goal = true;
            }
        }
    }
}

function goToPoint(player, point) {
    // using global collidingPlayer
    var collidingBlock;

    for (var i = 0; i < blocks.length; i++) {
        var block = blocks.getAt(i);
        if (block.alive) {
            if (block.x === point.x + BORDER_WIDTH && block.y === point.y + BORDER_WIDTH) {
                collidingBlock = block;
                break;
            }
        }
    }

    for (var i = 0; i < players.length; i++) {
        var otherPlayer = players.getAt(i);
        if (otherPlayer !== player) {
            if (otherPlayer.direction !== player.direction && otherPlayer.destination.equals(point)) {
                collidingPlayer = otherPlayer;
                break;
            }
        }
    }

    player.moving = true;
    player.destination = point;
    if (game.renderType === Phaser.WEBGL) {
        if (player.direction === DIRECTION.up || player.direction === DIRECTION.down) {
            player.filters = [blurY];
        } else {
            player.filters = [blurX];
        }
    }
    var tween = game.add.tween(player);
    tween.to({x: point.x, y: point.y}, PLAYER_SPEED);
    tween.onComplete.add(function() {
        player.moving = false;
        player.filters = undefined;

        if (collidingBlock) {
            collidingBlock.kill();
            player.direction = DIRECTION.none;
            soundHitBlock.play();
        }

        // This may have been set by the other player
        if (collidingPlayer) {
            player.direction = DIRECTION.none;
            if (collidingPlayer !== player) {
                collidingPlayer = undefined;
                soundHitPlayer.play();
            }
        }
    });
    tween.start();
}

function outOfBounds() {
    levelComplete = true;
    game.tweens.removeAll();

    // Blend from the current background color to #F00 65% interpolated
    var originalBackground = parseBackgroundColor()
    var tween = game.add.tween({percent:0.0});
    tween.to({percent: 65.0}, PLAYER_SPEED*6);
    tween.onUpdateCallback(function(tween) {
        var percent = tween._object.percent; // XXX: _object is undocumented
        var color = Phaser.Color.RGBtoWebstring(Phaser.Color.interpolateColor(originalBackground, 0xFF0000, 100, percent, 0));
        document.body.style.background = color;
        game.stage.backgroundColor = color;
    });
    tween.start();


    var text = "Game Over";
    var style = { font: "72px Arial", fill: "#ff0044", align: "center" };
    var t = game.add.text(game.camera.width/2, game.camera.height/2, text, style);
    t.fixedToCamera = true;
    t.anchor.setTo(0.5, 1);

    var text = "Press R to restart";
    var style = { font: "36px Arial", fill: "#ff0044", align: "center" };
    var t = game.add.text(game.camera.width/2, game.camera.height/2 + 54, text, style);
    t.fixedToCamera = true;
    t.anchor.setTo(0.5, 1);

    game.input.keyboard.onUpCallback = createLevel;
    game.input.onUp.addOnce(createLevel);
}

function countLivingGoalBlocks() {
    var count = 0;
    for (var i = 0; i < blocks.length; i++) {
        var block = blocks.getAt(i);
        if (block.alive && block.goal) {
            count++;
        }
    }
    return count;
}

function parseBackgroundColor() {
    var m = getComputedStyle(document.body).backgroundColor.match(/^rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)$/i);
    if (m) {
        return parseInt(m[1], 10) << 8*2 | parseInt(m[2], 10) << 8 | parseInt(m[3], 10);
    } else {
        throw new Error("Color could not be parsed");
    }
}

var game = new Phaser.Game(1000, 1000, Phaser.AUTO, '', {preload: preload, create: create, update: update});
</script>
